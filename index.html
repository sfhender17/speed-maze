<!DOCTYPE html>
<html>
<head>
    <title>+1 Speed Maze</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset and Global Styles */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000; /* Ensure black background for fade effects */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Shared UI Styles */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.3em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            border: 2px solid cyan;
            min-width: 350px;
            z-index: 100;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            animation: fadeIn 0.5s ease-out;
        }
        .ui-panel h2 {
            margin-top: 0;
            color: cyan;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px cyan;
        }
        .ui-panel button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            margin-top: 10px;
        }
        .ui-panel button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
        }
        .ui-panel button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* Specific UI Overrides */
        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2em;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            /* Changed from flex to none */
            display: none;
            flex-direction: column;
            gap: 5px;
            z-index: 90;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        #game-ui div {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 150px;
        }
        #game-ui span {
            font-weight: bold;
            color: lightgreen;
            margin-left: 10px;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.8em;
            display: none;
            z-index: 100;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
            border: 1px solid yellow;
        }

        #shop-ui .egg-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px;
            margin-bottom: 30px;
        }
        #shop-ui .egg-button {
            background-color: #333;
            color: white;
            border: 2px solid #555;
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s, border-color 0.3s, transform 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            min-width: 120px; /* Ensure buttons have a minimum width */
        }
        #shop-ui .egg-button:hover {
            background-color: #555;
            border-color: cyan;
            transform: translateY(-3px);
        }
        #shop-ui .egg-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        #shop-ui .egg-button span {
            font-weight: bold;
            color: lightgreen;
        }
        #shop-ui button.close-button {
            background-color: #dc3545;
            margin-top: 20px;
        }
        #shop-ui button.close-button:hover {
            background-color: #c82333;
        }

        #lobby-ui button {
            background-color: #28a745;
        }
        #lobby-ui button:hover {
            background-color: #218838;
        }
        #situp-progress {
            width: 80%;
            background-color: #333;
            border-radius: 5px;
            height: 20px;
            margin: 10px auto;
            overflow: hidden;
            border: 1px solid #555;
        }
        #situp-bar {
            height: 100%;
            width: 0%;
            background-color: #28a745;
            border-radius: 5px;
            transition: width 0.1s linear;
        }

        /* Fade Overlay for Transitions */
        #fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none; /* Allows clicks to pass through when hidden */
            transition: opacity 0.5s ease-in-out;
            z-index: 102; /* Above all other UI */
        }
        #fade-overlay.show {
            opacity: 1;
            pointer-events: all; /* Block clicks when visible */
        }

        /* Low Stamina Overlay */
        #stamina-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.2); /* Red tint */
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 80; /* Below UI, above game */
        }
        #stamina-overlay.low {
            opacity: 1;
            animation: pulseStamina 1s infinite alternate;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes pulseStamina {
            from { opacity: 0.2; }
            to { opacity: 0.4; }
        }
    </style>
</head>
<body>
    <div id="game-ui">
        <div>Coins: <span id="coins-display">0</span></div>
        <div>Level: <span id="level-display">1</span></div>
        <div>Time Left: <span id="time-display">5:00</span></div>
        <div>Stamina: <span id="stamina-display">100</span></div>
        <div>Speed: <span id="speed-display">1.0x</span></div>
        <div id="user-id-display" style="font-size: 0.8em; color: gray;">User ID: Loading...</div>
    </div>

    <div id="message-box"></div>

    <div id="main-menu" class="ui-panel">
        <h2>+1 Speed Maze</h2>
        <button id="play-game-button">Play Game</button>
        <button id="settings-button">Settings</button>
        <button id="credits-button">Credits</button>
    </div>

    <div id="settings-menu" class="ui-panel">
        <h2>Settings</h2>
        <p>Game settings will go here.</p>
        <button id="back-to-main-from-settings">Back</button>
    </div>

    <div id="credits-menu" class="ui-panel">
        <h2>Credits</h2>
        <p>Game developed by Gemini.</p>
        <p>Inspired by Roblox.</p>
        <button id="back-to-main-from-credits">Back</button>
    </div>

    <div id="pause-menu" class="ui-panel">
        <h2>Game Paused</h2>
        <button id="resume-button">Resume</button>
        <button id="restart-level-button">Restart Level</button>
        <button id="main-menu-from-pause">Main Menu</button>
    </div>

    <div id="game-over-screen" class="ui-panel">
        <h2>GAME OVER!</h2>
        <p id="game-over-message"></p>
        <p>Coins: <span id="game-over-coins">0</span></p>
        <p>Highest Level: <span id="game-over-level">0</span></p>
        <button id="restart-game-over-button">Restart Game</button>
        <button id="go-to-shop-game-over-button">Go to Shop</button>
    </div>

    <div id="game-won-screen" class="ui-panel">
        <h2>CONGRATULATIONS!</h2>
        <p>You completed all levels!</p>
        <p>Coins: <span id="game-won-coins">0</span></p>
        <p>Total Time: <span id="game-won-time"></span></p>
        <button id="restart-game-won-button">Play Again</button>
        <button id="main-menu-game-won-button">Main Menu</button>
    </div>

    <div id="shop-ui" class="ui-panel">
        <h2>Pet Shop</h2>
        <p>Current Coins: <span id="shop-coins-display">0</span></p>
        <div class="egg-container">
            <button class="egg-button" data-cost="10">
                Small Egg<br><span>10 Coins</span>
            </button>
            <button class="egg-button" data-cost="50">
                Medium Egg<br><span>50 Coins</span>
            </button>
            <button class="egg-button" data-cost="100">
                Large Egg<br><span>100 Coins</span>
            </button>
        </div>
        <div id="shop-message" style="color: yellow; margin-top: 10px;"></div>
        <button class="close-button" id="close-shop-button">Close Shop</button>
    </div>

    <div id="lobby-ui" class="ui-panel">
        <h2>Lobby</h2>
        <p>Take a break before the next level!</p>
        <p>Stamina: <span id="lobby-stamina-display">100</span></p>
        <button id="situp-button">Hold to Do Sit-ups</button>
        <div id="situp-progress"><div id="situp-bar"></div></div>
        <button id="next-level-button">Enter Next Level</button>
    </div>

    <div id="fade-overlay"></div>

    <div id="stamina-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Firebase Globals (Provided by Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db;
        let auth;
        let userId;
        let isAuthReady = false; // Flag to ensure auth is ready before Firestore ops

        // Initialize Firebase and Authenticate
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for auth state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase: User signed in:", userId);
                    } else {
                        // Sign in anonymously if no user and no custom token
                        if (!initialAuthToken) {
                            const anonymousUser = await signInAnonymously(auth);
                            userId = anonymousUser.user.uid;
                            console.log("Firebase: Signed in anonymously:", userId);
                        } else {
                            // If custom token exists but user is null, it means token might be invalid or not yet processed.
                            userId = null; // Explicitly set to null if no user
                        }
                    }
                    // Safely display userId, providing fallback if null
                    document.getElementById('user-id-display').textContent = `User ID: ${userId ? userId.substring(0, 8) + '...' : 'Loading...'}`;
                    isAuthReady = true; // Auth is now ready
                    loadGameData(); // Load data once authenticated
                });

                // Sign in with custom token if provided
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("Firebase: Signed in with custom token.");
                } else {
                    console.log("Firebase: No custom token, waiting for anonymous sign-in or existing session.");
                }

            } catch (error) {
                console.error("Firebase initialization or authentication error:", error);
                showMessage("Error loading game data. Please check console.", 5000);
            }
        }

        // --- Game Data Persistence (Firestore) ---
        async function saveGameData() {
            if (!isAuthReady || !userId) {
                console.warn("Firebase: Not authenticated or auth not ready. Cannot save data.");
                return;
            }
            try {
                const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/gameData`, 'playerProgress');
                const dataToSave = {
                    coins: coins,
                    highestLevel: Math.max(highestLevelReached, currentLevel), // Save the max of current or previous highest
                    petType: currentPetType,
                    petSpeedBoost: playerSpeedBoost,
                    totalGameTimeRecord: totalGameTimeRecord // Save best time if applicable
                };
                await setDoc(gameDataRef, dataToSave, { merge: true });
                console.log("Firebase: Game data saved successfully!");
            } catch (error) {
                console.error("Firebase: Error saving game data:", error);
            }
        }

        async function loadGameData() {
            if (!isAuthReady || !userId) {
                console.warn("Firebase: Not authenticated or auth not ready. Cannot load data.");
                return;
            }
            try {
                const gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/gameData`, 'playerProgress');
                const docSnap = await getDoc(gameDataRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    coins = data.coins || 0;
                    highestLevelReached = data.highestLevel || 1;
                    if (data.petType && data.petSpeedBoost) {
                        createPet(data.petType, data.petSpeedBoost, false); // Don't show message on load
                    }
                    totalGameTimeRecord = data.totalGameTimeRecord || 0;
                    console.log("Firebase: Game data loaded successfully!", data);
                } else {
                    console.log("Firebase: No saved game data found. Starting new game.");
                }
                updateUI(); // Update UI with loaded data
            } catch (error) {
                console.error("Firebase: Error loading game data:", error);
            }
        }

        // Call Firebase init when the script loads
        initFirebase();

        // --- Game State Variables (moved to global scope for access) ---
        let gameState = 'MENU'; // 'MENU', 'PLAYING', 'PAUSED', 'LOBBY', 'GAME_OVER', 'WON'
        let currentLevel = 1;
        let coins = 0;
        let totalGameTime = 5 * 60; // 5 minutes in seconds
        let levelTimeLimit = 60; // 1 minute per level
        let currentLevelTimer = levelTimeLimit;
        let stamina = 100;
        const MAX_STAMINA = 100;
        let playerSpeedBoost = 0; // Additional speed from pets
        let currentPetType = null; // Stores the type of the current pet
        let highestLevelReached = 1; // Track highest level for persistence
        let totalGameTimeRecord = 0; // Best time for completing all levels
        let gameRunning = false; // Added this line

        let situpProgress = 0;
        const SITUP_MAX_PROGRESS = 100;
        const SITUP_STAMINA_PER_CLICK = 5;
        let situpProgressInterval = null;

        // --- Three.js Scene Globals ---
        let scene, camera, renderer; // Declared globally here

        // --- Player ---
        let player; // Will be defined in initGame
        let playerBody; // Main body
        let playerHead; // Head for camera attachment
        let playerLeftArm, playerRightArm; // Arms for simple model
        let playerLegs; // Legs for simple model

        // Player movement variables
        let moveSpeed = 0.1; // Base movement speed
        const jumpForce = 0.2;
        const gravity = -0.01;
        let velocityY = 0;
        let isJumping = false;

        const moveDirection = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Mouse look variables
        let isPointerLocked = false;
        const PI_2 = Math.PI / 2;
        const pointerSpeed = 0.002;
        let yaw = new THREE.Object3D(); // For horizontal rotation
        let pitch = new THREE.Object3D(); // For vertical rotation

        // Player bounding box for collision detection
        const playerBoundingBox = new THREE.Box3();

        // --- UI Elements ---
        const gameUI = document.getElementById('game-ui');
        const coinsDisplay = document.getElementById('coins-display');
        const levelDisplay = document.getElementById('level-display');
        const timeDisplay = document.getElementById('time-display');
        const staminaDisplay = document.getElementById('stamina-display');
        const speedDisplay = document.getElementById('speed-display');
        const messageBox = document.getElementById('message-box');
        const staminaOverlay = document.getElementById('stamina-overlay');
        const fadeOverlay = document.getElementById('fade-overlay');

        // Menu elements
        const mainMenu = document.getElementById('main-menu');
        const playGameButton = document.getElementById('play-game-button');
        const settingsButton = document.getElementById('settings-button');
        const creditsButton = document.getElementById('credits-button');

        const settingsMenu = document.getElementById('settings-menu');
        const backToMainFromSettings = document.getElementById('back-to-main-from-settings');

        const creditsMenu = document.getElementById('credits-menu');
        const backToMainFromCredits = document.getElementById('back-to-main-from-credits');

        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const restartLevelButton = document.getElementById('restart-level-button');
        const mainMenuFromPause = document.getElementById('main-menu-from-pause');

        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverMessage = document.getElementById('game-over-message');
        const gameOverCoins = document.getElementById('game-over-coins');
        const gameOverLevel = document.getElementById('game-over-level');
        const restartGameOverButton = document.getElementById('restart-game-over-button');
        // Renamed and re-referenced this button
        const goToShopGameOverButton = document.getElementById('go-to-shop-game-over-button');

        const gameWonScreen = document.getElementById('game-won-screen');
        const gameWonCoins = document.getElementById('game-won-coins');
        const gameWonTime = document.getElementById('game-won-time');
        const restartGameWonButton = document.getElementById('restart-game-won-button');
        const mainMenuGameWonButton = document.getElementById('main-menu-game-won-button');

        const shopUI = document.getElementById('shop-ui');
        const shopCoinsDisplay = document.getElementById('shop-coins-display');
        const shopMessage = document.getElementById('shop-message');
        const closeShopButton = document.getElementById('close-shop-button');
        const eggButtons = document.querySelectorAll('.egg-button');

        const lobbyUI = document.getElementById('lobby-ui');
        const lobbyStaminaDisplay = document.getElementById('lobby-stamina-display');
        const situpButton = document.getElementById('situp-button');
        const situpProgressBar = document.getElementById('situp-bar');
        const nextLevelButton = document.getElementById('next-level-button');

        function updateUI() {
            coinsDisplay.textContent = coins;
            levelDisplay.textContent = currentLevel;
            const minutes = Math.floor(totalGameTime / 60);
            const seconds = Math.floor(totalGameTime % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `${minutes}:${seconds}`;
            staminaDisplay.textContent = Math.floor(stamina);
            speedDisplay.textContent = `${(1 + playerSpeedBoost).toFixed(1)}x`;
            shopCoinsDisplay.textContent = coins;
            lobbyStaminaDisplay.textContent = Math.floor(stamina);
            situpProgressBar.style.width = `${(situpProgress / SITUP_MAX_PROGRESS) * 100}%`;

            // Stamina low visual feedback
            if (stamina <= 20 && gameState === 'PLAYING') {
                staminaOverlay.classList.add('low');
            } else {
                staminaOverlay.classList.remove('low');
            }
        }

        function showMessage(msg, duration = 2000) {
            messageBox.textContent = msg;
            messageBox.style.display = 'block';
            // Stop existing timeout if any
            if (messageBox.timeout) clearTimeout(messageBox.timeout);
            messageBox.timeout = setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        function setGameState(newState) {
            // Hide all UI panels first
            mainMenu.style.display = 'none';
            settingsMenu.style.display = 'none';
            creditsMenu.style.display = 'none';
            pauseMenu.style.display = 'none';
            gameOverScreen.style.display = 'none';
            gameWonScreen.style.display = 'none';
            shopUI.style.display = 'none';
            lobbyUI.style.display = 'none';
            gameUI.style.display = 'none'; // Hide in-game UI by default

            // Stop all audio, but only if they are defined
            if (backgroundMusic) stopAllAudio();

            // Handle state transitions
            switch (newState) {
                case 'MENU':
                    mainMenu.style.display = 'flex';
                    if (menuMusic) startMenuMusic();
                    break;
                case 'PLAYING':
                    gameUI.style.display = 'flex';
                    if (backgroundMusic) startBackgroundMusic();
                    // Lock pointer when starting game
                    console.log("Attempting pointer lock. Renderer:", renderer); // Debugging line
                    if (renderer && renderer.domElement && document.pointerLockElement !== renderer.domElement) {
                        renderer.domElement.requestPointerLock();
                    }
                    break;
                case 'PAUSED':
                    pauseMenu.style.display = 'flex';
                    break;
                case 'LOBBY':
                    lobbyUI.style.display = 'flex';
                    if (menuMusic) startMenuMusic(); // Lobby uses menu music
                    break;
                case 'SHOP':
                    shopUI.style.display = 'flex';
                    if (menuMusic) startMenuMusic(); // Shop uses menu music
                    break;
                case 'GAME_OVER':
                    gameOverScreen.style.display = 'flex';
                    if (menuMusic) startMenuMusic(); // Game over uses menu music
                    break;
                case 'WON':
                    gameWonScreen.style.display = 'flex';
                    if (menuMusic) startMenuMusic(); // Game won uses menu music
                    break;
                case 'SETTINGS':
                    settingsMenu.style.display = 'flex';
                    break;
                case 'CREDITS':
                    creditsMenu.style.display = 'flex';
                    break;
            }
            gameState = newState;
            console.log("Game State:", gameState);
        }

        function fadeScreen(callback, duration = 500) {
            fadeOverlay.classList.add('show');
            setTimeout(() => {
                callback();
                fadeOverlay.classList.remove('show');
            }, duration);
        }

        // --- Game Objects (Levels, Obstacles, Enemies, Food, Laser Door, Coins) ---
        const levelObjects = new THREE.Group(); // Group to hold all objects for the current level
        // scene.add(levelObjects); // This line needs to be called after scene is defined

        // --- Object Creation Functions ---

        // Player Model (more detailed blocky)
        function createPlayerModel() {
            player = new THREE.Group(); // Player is now a group
            player.position.y = 1; // Start player on the ground

            // Body
            playerBody = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1.2, 0.8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // Green body
            );
            playerBody.position.y = 0.6; // Center of body
            player.add(playerBody);

            // Head
            playerHead = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                new THREE.MeshBasicMaterial({ color: 0x00aaff }) // Blue head
            );
            playerHead.position.y = 1.6; // On top of body
            player.add(playerHead);

            // Camera attached to head
            camera.position.set(0, 0.2, 0); // Relative to head
            playerHead.add(camera);

            // Arms (simple cubes)
            playerLeftArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.8, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xcc9966 }) // Skin tone
            );
            playerLeftArm.position.set(-0.65, 0.6, 0);
            player.add(playerLeftArm);

            playerRightArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.8, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xcc9966 })
            );
            playerRightArm.position.set(0.65, 0.6, 0);
            player.add(playerRightArm);

            // Legs (simple cubes)
            playerLegs = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.7),
                new THREE.MeshBasicMaterial({ color: 0x3333ff }) // Blue pants
            );
            playerLegs.position.y = 0.2;
            player.add(playerLegs);

            scene.add(player);

            // Setup mouse look
            yaw.position.y = 1; // Yaw is at player height
            yaw.add(pitch);
            pitch.add(camera);
            scene.add(yaw);
        }

        // Function to create a simple blocky wall
        function createWall(x, y, z, width, height, depth, color = 0xaaaaaa) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true }); // Use StandardMaterial for better lighting
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y + height / 2, z); // Position based on center
            return wall;
        }

        // Function to create a floor
        function createFloor(x, y, z, width, depth, color = 0x808080) {
            const geometry = new THREE.BoxGeometry(width, 1, depth);
            const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true });
            const floor = new THREE.Mesh(geometry, material);
            floor.position.set(x, y - 0.5, z); // Position based on center
            return floor;
        }

        // Function to create a simple obstacle (e.g., a static block)
        function createObstacle(x, y, z, width = 2, height = 2, depth = 2, color = 0xff0000) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true });
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(x, y + height / 2, z);
            return obstacle;
        }

        // Function to create a food item (with particle effect)
        function createFood(x, y, z, color = 0xffa500) { // Orange for food
            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true });
            const food = new THREE.Mesh(geometry, material);
            food.position.set(x, y + 0.25, z);
            food.isFood = true; // Custom property for identification
            return food;
        }

        // Function to create a rotating coin model
        function createCoin(x, y, z, color = 0xffd700) { // Gold color
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16); // Thin cylinder
            const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true, metalness: 0.8, roughness: 0.2 });
            const coin = new THREE.Mesh(geometry, material);
            coin.position.set(x, y + 0.5, z);
            coin.rotation.x = Math.PI / 2; // Lay flat
            coin.isCoin = true;
            return coin;
        }

        // Function to create an enemy (simple blocky models)
        function createEnemy(x, y, z, type = 'wolf') {
            const enemyGroup = new THREE.Group();
            enemyGroup.position.set(x, y, z);
            enemyGroup.isEnemy = true;
            enemyGroup.type = type;
            enemyGroup.speed = 0.02 + (currentLevel * 0.005); // Enemies get faster
            enemyGroup.initialPosition = new THREE.Vector3(x, y, z);
            enemyGroup.range = 5 + currentLevel; // How far it patrols/chases
            enemyGroup.direction = new THREE.Vector3(Math.random() > 0.5 ? 1 : -1, 0, Math.random() > 0.5 ? 1 : -1).normalize();
            enemyGroup.chaseRange = 7; // Distance at which enemy starts chasing

            let bodyColor, headColor;
            switch(type) {
                case 'Dog':
                    bodyColor = 0x8B4513; // Brown
                    headColor = 0xA0522D;
                    break;
                case 'Fox':
                    bodyColor = 0xFF4500; // Orange-Red
                    headColor = 0xDC143C;
                    break;
                case 'Wolf':
                    bodyColor = 0x708090; // Slate Gray
                    headColor = 0x506070;
                    break;
            }

            // Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1.5),
                new THREE.MeshStandardMaterial({ color: bodyColor, flatShading: true })
            );
            body.position.y = 0.5;
            enemyGroup.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                new THREE.MeshStandardMaterial({ color: headColor, flatShading: true })
            );
            head.position.set(0, 1.2, 0.5);
            enemyGroup.add(head);

            // Legs (simple cylinders)
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8),
                    new THREE.MeshStandardMaterial({ color: bodyColor, flatShading: true })
                );
                leg.position.set(
                    (i % 2 === 0 ? -0.3 : 0.3),
                    0.25,
                    (i < 2 ? 0.5 : -0.5)
                );
                enemyGroup.add(leg);
            }

            return enemyGroup;
        }

        // Function to create a simple blocky pet model
        function createPetModel(type) {
            const petGroup = new THREE.Group();
            let bodyColor, headColor;
            switch(type) {
                case 'Dog':
                    bodyColor = 0x8B4513; // Brown
                    headColor = 0xA0522D;
                    break;
                case 'Fox':
                    bodyColor = 0xFF4500; // Orange-Red
                    headColor = 0xDC143C;
                    break;
                case 'Wolf':
                    bodyColor = 0x708090; // Slate Gray
                    headColor = 0x506070;
                    break;
            }

            // Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.6, 1),
                new THREE.MeshStandardMaterial({ color: bodyColor, flatShading: true })
            );
            body.position.y = 0.3;
            petGroup.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshStandardMaterial({ color: headColor, flatShading: true })
            );
            head.position.set(0, 0.8, 0.3);
            petGroup.add(head);

            // Legs
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8),
                    new THREE.MeshStandardMaterial({ color: bodyColor, flatShading: true })
                );
                leg.position.set(
                    (i % 2 === 0 ? -0.2 : 0.2),
                    0.15,
                    (i < 2 ? 0.3 : -0.3)
                );
                petGroup.add(leg);
            }
            return petGroup;
        }

        // Dynamic Obstacles
        function createMovingPlatform(x, y, z, width, height, depth, travelDistance, axis = 'x') {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: 0x800080, flatShading: true }); // Purple platform
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y + height / 2, z);
            platform.initialPosition = platform.position.clone();
            platform.travelDistance = travelDistance;
            platform.axis = axis;
            platform.speed = 0.03;
            platform.direction = 1; // 1 for forward, -1 for backward
            platform.isDynamicObstacle = true;
            return platform;
        }

        function createLaserGrid(x, y, z, width, height, depth, interval = 3000) {
            const laserGridGroup = new THREE.Group();
            laserGridGroup.position.set(x, y + height / 2, z);
            laserGridGroup.isDynamicObstacle = true;
            laserGridGroup.isLaserGrid = true;
            laserGridGroup.isActive = true; // Starts active
            laserGridGroup.interval = interval;
            laserGridGroup.lastToggleTime = Date.2now();

            const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6, emissive: 0xff0000, emissiveIntensity: 0.8 });

            // Create multiple laser beams
            const numLasers = Math.floor(width / 1) + 1; // 1 unit spacing
            for (let i = 0; i < numLasers; i++) {
                const laserBeam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, height, 0.1), // Thin vertical beam
                    laserMaterial
                );
                laserBeam.position.x = (i - numLasers / 2 + 0.5) * 1;
                laserGridGroup.add(laserBeam);
            }
            return laserGridGroup;
        }

        // --- Particle System (Simple for now) ---
        function createParticles(position, color, count = 20, size = 0.1, duration = 1000) {
            const particles = new THREE.Group();
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 8),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 })
                );
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1 + 0.05, // Slight upward bias
                    (Math.random() - 0.5) * 0.1
                );
                particles.add(particle);
            }
            scene.add(particles);

            const startTime = Date.now();
            function animateParticles() {
                const elapsed = Date.now() - startTime;
                if (elapsed > duration) {
                    scene.remove(particles);
                    return;
                }

                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.material.opacity = 1 - (elapsed / duration);
                });
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        // --- Audio Setup (Tone.js) ---
        let backgroundMusic;
        let menuMusic;
        let jumpSound;
        let coinSound;
        let hitSound;
        let laserSound;
        let purchaseSound;
        let staminaLowSound;

        async function setupAudio() {
            await Tone.start(); // Start Tone.js audio context

            // Background Music (simple synth loop)
            backgroundMusic = new Tone.Loop(time => {
                const synth = new Tone.Synth().toDestination();
                synth.triggerAttackRelease("C4", "8n", time);
                synth.triggerAttackRelease("E4", "8n", time + 0.25);
                synth.triggerAttackRelease("G4", "8n", time + 0.5);
            }, "1n").start(0);
            backgroundMusic.mute = true; // Start muted, play when needed

            menuMusic = new Tone.Loop(time => {
                const synth = new Tone.Synth().toDestination();
                synth.triggerAttackRelease("C3", "4n", time);
                synth.triggerAttackRelease("G3", "4n", time + 0.5);
            }, "1n").start(0);
            menuMusic.mute = true;

            // Sound Effects (simple synths)
            jumpSound = new Tone.Synth().toDestination();
            coinSound = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
            }).toDestination();
            hitSound = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
            }).toDestination();
            laserSound = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }
            }).toDestination();
            purchaseSound = new Tone.PolySynth(Tone.Synth).toDestination();
            staminaLowSound = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 }
            }).toDestination();
        }

        function startBackgroundMusic() {
            if (backgroundMusic) backgroundMusic.mute = false;
            if (menuMusic) menuMusic.mute = true;
        }

        function startMenuMusic() {
            if (backgroundMusic) backgroundMusic.mute = true;
            if (menuMusic) menuMusic.mute = false;
        }

        function stopAllAudio() {
            if (backgroundMusic) backgroundMusic.mute = true;
            if (menuMusic) menuMusic.mute = true;
        }

        // --- Game Setup and Flow ---
        async function initGame() { // Made initGame async
            // Scene, Camera, Renderer setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add levelObjects to scene after scene is defined
            scene.add(levelObjects);

            // Add lights
            scene.add(new THREE.AmbientLight(0x404040, 2)); // Soft white light
            scene.add(new THREE.DirectionalLight(0xffffff, 1)); // White light
            scene.add(new THREE.HemisphereLight(0xadd8e6, 0x000000, 0.5)); // Sky color, ground color, intensity

            // Skybox (simple gradient for now)
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x87ceeb, // Light blue
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Create player model
            createPlayerModel();

            // Setup audio - AWAIT this call
            await setupAudio();

            // Set initial game state to MENU
            setGameState('MENU');

            // Attach mouse look event listeners after renderer.domElement is available
            renderer.domElement.addEventListener('click', () => {
                if (gameState === 'PLAYING' && !isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                if (isPointerLocked) {
                    document.addEventListener('mousemove', onMouseMove, false);
                } else {
                    document.removeEventListener('mousemove', onMouseMove, false);
                    // If pointer lock is lost during gameplay, pause the game
                    if (gameState === 'PLAYING') {
                        pauseGame();
                    }
                }
            });

            // Start animation loop
            animate();
        }

        function resetGame() {
            currentLevel = 1;
            coins = 0;
            totalGameTime = 5 * 60;
            levelTimeLimit = 60;
            currentLevelTimer = levelTimeLimit;
            stamina = MAX_STAMINA;
            playerSpeedBoost = 0;
            currentPetType = null;
            if (currentPet) {
                scene.remove(currentPet);
                currentPet = null;
            }
            highestLevelReached = 1; // Reset highest level on full game restart
            totalGameTimeRecord = 0; // Reset best time on full game restart

            // Reset player position and rotation
            player.position.set(0, 1, 0);
            yaw.rotation.y = 0;
            pitch.rotation.x = 0;

            updateUI();
            saveGameData(); // Save reset state
        }

        function startGame() {
            fadeScreen(() => {
                resetGame(); // Reset all game state
                generateLevel(currentLevel);
                setGameState('PLAYING');
                totalGameClock.start(); // Restart total game clock
            });
        }

        function pauseGame() {
            if (gameState === 'PLAYING') {
                setGameState('PAUSED');
                document.exitPointerLock(); // Release pointer lock
            }
        }

        function resumeGame() {
            if (gameState === 'PAUSED') {
                setGameState('PLAYING');
                renderer.domElement.requestPointerLock(); // Re-lock pointer
            }
        }

        function restartLevel() {
            fadeScreen(() => {
                stamina = MAX_STAMINA; // Full stamina on level restart
                currentLevelTimer = levelTimeLimit; // Reset level timer
                generateLevel(currentLevel); // Regenerate current level
                setGameState('PLAYING');
            });
        }

        function goToMainMenu() {
            fadeScreen(() => {
                resetGame(); // Reset game state fully
                setGameState('MENU');
                document.exitPointerLock(); // Ensure pointer is unlocked
            });
        }

        function gameOver(message) {
            gameRunning = false;
            gameOverMessage.textContent = message;
            gameOverCoins.textContent = coins;
            gameOverLevel.textContent = currentLevel;
            saveGameData(); // Save current progress
            setGameState('GAME_OVER');
            document.exitPointerLock();
        }

        function gameWon() {
            gameRunning = false;
            gameWonCoins.textContent = coins;
            const finalMinutes = Math.floor((5 * 60 - totalGameTime) / 60);
            const finalSeconds = Math.floor((5 * 60 - totalGameTime) % 60).toString().padStart(2, '0');
            gameWonTime.textContent = `${finalMinutes}:${finalSeconds}`;
            totalGameTimeRecord = (totalGameTimeRecord === 0 || (5 * 60 - totalGameTime) < totalGameTimeRecord) ? (5 * 60 - totalGameTime) : totalGameTimeRecord; // Save best time
            highestLevelReached = Math.max(highestLevelReached, currentLevel); // Ensure highest level is saved
            saveGameData(); // Save final progress
            setGameState('WON');
            document.exitPointerLock();
        }

        // --- Level Generation ---
        function generateLevel(levelNum) {
            // Clear previous level objects
            while (levelObjects.children.length > 0) {
                levelObjects.remove(levelObjects.children[0]);
            }
            foodItems = [];
            enemies = [];
            coinsInLevel = [];
            dynamicObstacles = [];

            // Reset player position for new level
            player.position.set(0, 1, 0);
            yaw.rotation.y = 0; // Reset player rotation (yaw)
            pitch.rotation.x = 0; // Reset camera pitch

            // Level specific difficulty adjustments
            const levelSize = 20 + levelNum * 5; // Levels get larger
            const numObstacles = 2 + Math.floor(levelNum / 2);
            const numFood = 1 + Math.floor(levelNum / 3);
            const numCoins = 3 + Math.floor(levelNum / 2);
            const numEnemies = levelNum > 3 ? (levelNum - 3) * 1 : 0; // Enemies after level 3
            const hasMovingPlatform = levelNum >= 2;
            const hasLaserGrid = levelNum >= 4;

            // Floor
            levelObjects.add(createFloor(0, 0, 0, levelSize, levelSize, 0x808080));

            // Walls (simple square room for now)
            levelObjects.add(createWall(0, 0, -levelSize / 2, levelSize, 3, 1, 0x666666)); // Back wall
            levelObjects.add(createWall(0, 0, levelSize / 2, levelSize, 3, 1, 0x666666));  // Front wall
            levelObjects.add(createWall(-levelSize / 2, 0, 0, 1, 3, levelSize, 0x666666)); // Left wall
            levelObjects.add(createWall(levelSize / 2, 0, 0, 1, 3, levelSize, 0x666666));  // Right wall

            // Obstacles
            for (let i = 0; i < numObstacles; i++) {
                const x = (Math.random() - 0.5) * (levelSize - 5);
                const z = (Math.random() - 0.5) * (levelSize - 5);
                levelObjects.add(createObstacle(x, 0, z));
            }

            // Food items
            for (let i = 0; i < numFood; i++) {
                const x = (Math.random() - 0.5) * (levelSize - 5);
                const z = (Math.random() - 0.5) * (levelSize - 5);
                const food = createFood(x, 0, z);
                levelObjects.add(food);
                foodItems.push(food);
            }

            // Coins
            for (let i = 0; i < numCoins; i++) {
                const x = (Math.random() - 0.5) * (levelSize - 5);
                const z = (Math.random() - 0.5) * (levelSize - 5);
                const coin = createCoin(x, 0, z);
                levelObjects.add(coin);
                coinsInLevel.push(coin);
            }

            // Enemies
            for (let i = 0; i < numEnemies; i++) {
                const x = (Math.random() - 0.5) * (levelSize - 5);
                const z = (Math.random() - 0.5) * (levelSize - 5);
                const enemy = createEnemy(x, 0, z, petTypes[Math.floor(Math.random() * petTypes.length)]); // Random enemy type
                levelObjects.add(enemy);
                enemies.push(enemy);
            }

            // Dynamic Obstacles
            if (hasMovingPlatform) {
                const platform = createMovingPlatform(5, 0, -5, 4, 0.5, 4, 10, 'z'); // Moves along Z axis
                levelObjects.add(platform);
                dynamicObstacles.push(platform);
            }
            if (hasLaserGrid) {
                const laserGrid = createLaserGrid(-5, 0, 5, 8, 3, 1, 2500); // Toggles every 2.5 seconds
                levelObjects.add(laserGrid);
                dynamicObstacles.push(laserGrid);
            }

            // Laser Door
            laserDoor = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 0.5),
                new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5, emissive: 0x0000ff, emissiveIntensity: 0.5 })
            );
            laserDoor.position.set(levelSize / 2 - 2, 1.5, levelSize / 2 - 2); // Position near a corner exit
            levelObjects.add(laserDoor);
            laserDoor.isLaserDoor = true; // Custom property for identification

            currentLevelTimer = levelTimeLimit; // Reset level timer
            showMessage(`Level ${levelNum} - Go!`, 3000);
        }

        // --- Pets ---
        let currentPet = null; // Stores the current pet mesh
        const petTypes = ['Dog', 'Fox', 'Wolf'];
        const petColors = {
            'Dog': 0x8B4513, // Brown
            'Fox': 0xFF4500, // Orange-Red
            'Wolf': 0x708090  // Slate Gray
        };

        function createPet(type, speedBoost, showMsg = true) {
            if (currentPet) {
                scene.remove(currentPet);
                currentPet = null;
            }

            const pet = createPetModel(type);
            pet.position.set(player.position.x + 1, player.position.y, player.position.z + 1); // Initially beside player
            scene.add(pet);
            currentPet = pet;
            currentPetType = type; // Store the type for persistence
            playerSpeedBoost = speedBoost;
            if (showMsg) {
                showMessage(`You got a ${type}! Speed increased by ${Math.round(speedBoost * 100)}%`, 3000);
                if (purchaseSound) purchaseSound.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                createParticles(player.position, petColors[type], 30, 0.2, 1500);
            }
            updateUI();
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (event) => {
            if (gameState === 'PLAYING') {
                switch (event.key) {
                    case 'ArrowUp':
                        moveDirection.forward = true;
                        break;
                    case 'ArrowDown':
                        moveDirection.backward = true;
                        break;
                    case 'ArrowLeft':
                        moveDirection.left = true;
                        break;
                    case 'ArrowRight':
                        moveDirection.right = true;
                        break;
                    case ' ': // Spacebar for jump
                        if (!isJumping && stamina > 0) {
                            velocityY = jumpForce;
                            isJumping = true;
                            stamina -= 5; // Stamina cost for jump
                            if (stamina < 0) stamina = 0;
                            if (jumpSound) jumpSound.triggerAttackRelease("C4", "8n");
                        }
                        break;
                    case 'Escape': // Esc key for pause
                        pauseGame();
                        break;
                }
            } else if (event.key === 'Escape' && (gameState === 'PAUSED' || gameState === 'SHOP' || gameState === 'LOBBY')) {
                // Allow escape to close menus or resume from pause
                if (gameState === 'PAUSED') resumeGame();
                else if (gameState === 'SHOP') setGameState('PLAYING'); // Close shop and go back to game
                else if (gameState === 'LOBBY') {
                    // If in lobby, pressing escape will take you back to game, but you need to click next level to advance
                    setGameState('PLAYING');
                    showMessage("Click 'Enter Next Level' to advance!", 2000);
                }
            }
            if (event.key === 'F2' && gameState === 'PLAYING') { // F2 to open shop only during gameplay
                setGameState('SHOP');
                if (renderer && document.pointerLockElement === renderer.domElement) { // Added renderer check
                    document.exitPointerLock(); // Release pointer lock for shop
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (gameState === 'PLAYING') {
                switch (event.key) {
                    case 'ArrowUp':
                        moveDirection.forward = false;
                        break;
                    case 'ArrowDown':
                        moveDirection.backward = false;
                        break;
                    case 'ArrowLeft':
                        moveDirection.left = false;
                        break;
                    case 'ArrowRight':
                        moveDirection.right = false;
                        break;
                }
            }
        });

        // UI Button Event Listeners
        playGameButton.addEventListener('click', startGame);
        settingsButton.addEventListener('click', () => setGameState('SETTINGS'));
        creditsButton.addEventListener('click', () => setGameState('CREDITS'));
        backToMainFromSettings.addEventListener('click', () => setGameState('MENU'));
        backToMainFromCredits.addEventListener('click', () => setGameState('MENU'));
        resumeButton.addEventListener('click', resumeGame);
        restartLevelButton.addEventListener('click', restartLevel);
        mainMenuFromPause.addEventListener('click', goToMainMenu);
        restartGameOverButton.addEventListener('click', startGame);
        // Updated event listener for the "Go to Shop" button on game over
        goToShopGameOverButton.addEventListener('click', () => setGameState('SHOP'));
        restartGameWonButton.addEventListener('click', startGame);
        mainMenuGameWonButton.addEventListener('click', goToMainMenu);
        closeShopButton.addEventListener('click', () => setGameState('PLAYING')); // Close shop, return to game

        eggButtons.forEach(button => {
            button.addEventListener('click', () => {
                const cost = parseInt(button.dataset.cost);
                if (coins >= cost) {
                    coins -= cost;
                    const randomPetType = petTypes[Math.floor(Math.random() * petTypes.length)];
                    const randomSpeedBoost = (Math.random() * 0.4) + 0.1; // 0.1 to 0.5 (10% to 50%)
                    createPet(randomPetType, randomSpeedBoost);
                    shopMessage.textContent = `You bought a ${randomPetType} egg!`;
                    updateUI();
                    saveGameData(); // Save after purchasing a pet
                } else {
                    shopMessage.textContent = 'Not enough coins!';
                }
            });
        });

        situpButton.addEventListener('mousedown', () => {
            if (stamina < MAX_STAMINA) {
                situpProgressInterval = setInterval(() => {
                    situpProgress += 1;
                    if (situpProgress > SITUP_MAX_PROGRESS) situpProgress = SITUP_MAX_PROGRESS;
                    situpProgressBar.style.width = `${(situpProgress / SITUP_MAX_PROGRESS) * 100}%`;
                }, 10); // Faster progress for demonstration
            }
        });

        situpButton.addEventListener('mouseup', () => {
            clearInterval(situpProgressInterval);
            const staminaGained = Math.floor((situpProgress / SITUP_MAX_PROGRESS) * (MAX_STAMINA / 4)); // Max 25 stamina from one situp session
            stamina += staminaGained;
            if (stamina > MAX_STAMINA) stamina = MAX_STAMINA;
            situpProgress = 0; // Reset progress
            situpProgressBar.style.width = '0%';
            lobbyStaminaDisplay.textContent = Math.floor(stamina);
            showMessage(`Gained ${staminaGained} stamina!`, 1500);
            saveGameData(); // Save after gaining stamina
        });

        nextLevelButton.addEventListener('click', () => {
            fadeScreen(() => {
                currentLevel++;
                if (currentLevel > 10) {
                    gameWon(); // Player won all levels
                } else {
                    generateLevel(currentLevel);
                    setGameState('PLAYING');
                }
            });
        });

        // --- Game Logic ---
        function checkCollisions() {
            // Update player bounding box based on yaw rotation
            const playerPosition = player.position.clone();
            playerBoundingBox.setFromCenterAndSize(playerPosition, new THREE.Vector3(1, 2, 1)); // Player size

            // Check collision with laser door
            if (laserDoor && playerBoundingBox.intersectsBox(new THREE.Box3().setFromObject(laserDoor))) {
                if (gameState === 'PLAYING') {
                    if (laserSound) laserSound.triggerAttackRelease("C6", "8n");
                    createParticles(laserDoor.position, 0x0000ff, 50, 0.2, 1000);
                    coins += (10 * currentLevel); // Coins increase with level
                    highestLevelReached = Math.max(highestLevelReached, currentLevel); // Update highest level
                    saveGameData(); // Save progress
                    showMessage(`Level ${currentLevel} Complete! +${10 * currentLevel} Coins!`, 2000);
                    setTimeout(() => {
                        setGameState('LOBBY'); // Go to lobby
                    }, 2500);
                }
            }

            // Check collision with food items
            foodItems.forEach((food, index) => {
                if (playerBoundingBox.intersectsBox(new THREE.Box3().setFromObject(food))) {
                    stamina += 20; // Gain 20 stamina per food
                    if (stamina > MAX_STAMINA) stamina = MAX_STAMINA;
                    levelObjects.remove(food);
                    foodItems.splice(index, 1); // Remove from array
                    showMessage('Ate food! Stamina +20', 1000);
                    if (coinSound) coinSound.triggerAttackRelease("G5", "16n");
                    createParticles(food.position, 0xffa500, 15, 0.1, 800);
                }
            });

            // Check collision with coins
            coinsInLevel.forEach((coin, index) => {
                if (playerBoundingBox.intersectsBox(new THREE.Box3().setFromObject(coin))) {
                    coins += 1; // Each coin gives 1 coin
                    levelObjects.remove(coin);
                    coinsInLevel.splice(index, 1); // Remove from array
                    if (coinSound) coinSound.triggerAttackRelease("C5", "16n");
                    createParticles(coin.position, 0xffd700, 10, 0.1, 500);
                }
            });

            // Check collision with enemies (simple reset for now)
            enemies.forEach(enemy => {
                if (playerBoundingBox.intersectsBox(new THREE.Box3().setFromObject(enemy))) {
                    showMessage('Hit by enemy! Returning to start...', 2000);
                    player.position.set(0, 1, 0); // Reset player position
                    stamina -= 10; // Lose stamina on hit
                    if (stamina < 0) stamina = 0;
                    if (hitSound) hitSound.triggerAttackRelease("8n");
                }
            });

            // Check collision with laser grids
            dynamicObstacles.forEach(obstacle => {
                if (obstacle.isLaserGrid && obstacle.isActive) {
                    const laserGridBoundingBox = new THREE.Box3().setFromObject(obstacle);
                    if (playerBoundingBox.intersectsBox(laserGridBoundingBox)) {
                        showMessage('Hit by laser! Stamina -15', 1500);
                        stamina -= 15;
                        if (stamina < 0) stamina = 0;
                        if (hitSound) hitSound.triggerAttackRelease("8n");
                        player.position.set(0, 1, 0); // Reset player position
                    }
                }
            });

            // Basic wall collision (prevent going through walls)
            levelObjects.children.forEach(obj => {
                // Only check collision for static walls and obstacles (not food, enemies, laser door, or dynamic obstacles)
                if (obj.geometry.type === 'BoxGeometry' && !obj.isLaserDoor && !obj.isFood && !obj.isEnemy && !obj.isDynamicObstacle) {
                    const objBoundingBox = new THREE.Box3().setFromObject(obj);
                    if (playerBoundingBox.intersectsBox(objBoundingBox)) {
                        // Simple push-back logic to prevent passing through
                        const playerPos = player.position.clone();
                        const objCenter = objBoundingBox.getCenter(new THREE.Vector3()); // Define objCenter here

                        // Calculate intersection
                        // const intersection = playerBoundingBox.intersectsBox(objBoundingBox); // This line is not needed for simple push-back

                        // Determine which axis has the smallest overlap
                        const xOverlap = Math.min(playerBoundingBox.max.x - objBoundingBox.min.x, objBoundingBox.max.x - playerBoundingBox.min.x);
                        const zOverlap = Math.min(playerBoundingBox.max.z - objBoundingBox.min.z, objBoundingBox.max.z - playerBoundingBox.min.z);

                        if (xOverlap < zOverlap) {
                            // Push back along X axis
                            if (playerPos.x > objCenter.x) { // Player is to the right of obstacle
                                player.position.x = objBoundingBox.max.x + playerBoundingBox.getSize(new THREE.Vector3()).x / 2;
                            } else { // Player is to the left
                                player.position.x = objBoundingBox.min.x - playerBoundingBox.getSize(new THREE.Vector3()).x / 2;
                            }
                        } else {
                            // Push back along Z axis
                            if (playerPos.z > objCenter.z) { // Player is in front of obstacle
                                player.position.z = objBoundingBox.max.z + playerBoundingBox.getSize(new THREE.Vector3()).z / 2;
                            } else { // Player is behind
                                player.position.z = objBoundingBox.min.z - playerBoundingBox.getSize(new THREE.Vector3()).z / 2;
                            }
                        }
                    }
                }
            });
        }

        // --- Animation Loop ---
        let lastUpdateTime = 0;
        const totalGameClock = new THREE.Clock(); // For total game time
        totalGameClock.start(); // Start clock immediately for total game time tracking

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (!lastUpdateTime) lastUpdateTime = currentTime;
            const deltaTime = (currentTime - lastUpdateTime) / 1000; // Convert to seconds
            lastUpdateTime = currentTime;

            // Update player position based on yaw rotation
            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(yaw.quaternion);
            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(yaw.quaternion);
            const currentMoveVector = new THREE.Vector3();

            if (gameState === 'PLAYING') {
                // Update total game time
                totalGameTime -= deltaTime;
                if (totalGameTime <= 0) {
                    totalGameTime = 0;
                    gameOver('Time ran out!');
                    return; // Exit animate loop early if game over
                }

                // Update level timer
                currentLevelTimer -= deltaTime;
                if (currentLevelTimer <= 0) {
                    currentLevelTimer = 0;
                    showMessage('Time for this level ran out! Try again!', 2000);
                    player.position.set(0, 1, 0); // Reset player to start of level
                    currentLevelTimer = levelTimeLimit; // Reset level timer
                    stamina -= 20; // Penalty for running out of time
                    if (stamina < 0) stamina = 0;
                    if (stamina === 0) {
                        gameOver('Stamina depleted!');
                        return;
                    }
                }

                // Stamina depletion
                const currentMoveSpeed = moveSpeed * (1 + playerSpeedBoost);
                if ((moveDirection.forward || moveDirection.backward || moveDirection.left || moveDirection.right) && stamina > 0) {
                    stamina -= 0.05; // Stamina depletion while moving
                    if (stamina < 0) stamina = 0;
                }
                if (stamina === 0 && (moveDirection.forward || moveDirection.backward || moveDirection.left || moveDirection.right || isJumping)) {
                    showMessage('Out of stamina! Find food or do sit-ups!', 1500);
                    // Significantly slow down player if out of stamina
                    moveSpeed = 0.02; // Very slow movement
                    if (staminaLowSound && staminaLowSound.state !== "started") {
                        staminaLowSound.triggerAttackRelease("C2", "0.5", Tone.now(), 0.5); // Low pulse sound
                    }
                } else {
                    moveSpeed = 0.1; // Restore normal speed
                    if (staminaLowSound) staminaLowSound.stop();
                }

                // Apply movement based on camera direction
                if (moveDirection.forward) currentMoveVector.add(forwardVector);
                if (moveDirection.backward) currentMoveVector.sub(forwardVector);
                if (moveDirection.left) currentMoveVector.sub(rightVector);
                if (moveDirection.right) currentMoveVector.add(rightVector);

                currentMoveVector.normalize().multiplyScalar(currentMoveSpeed);
                player.position.add(currentMoveVector);
                player.userData.lastMoveVector = currentMoveVector; // Store for collision push-back

                // Update player's yaw position to match player's XZ position
                yaw.position.x = player.position.x;
                yaw.position.z = player.position.z;

                // Jumping and gravity
                velocityY += gravity;
                player.position.y += velocityY;

                // Ground detection
                if (player.position.y < 1) {
                    player.position.y = 1;
                    velocityY = 0;
                    isJumping = false;
                }

                // Update enemy movement (simple patrol or chase)
                enemies.forEach(enemy => {
                    const distanceToPlayer = enemy.position.distanceTo(player.position);
                    if (distanceToPlayer < enemy.chaseRange && stamina > 0) { // Chase if player is close and player has stamina
                        const chaseDirection = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
                        enemy.position.add(chaseDirection.multiplyScalar(enemy.speed));
                    } else { // Patrol
                        enemy.position.add(enemy.direction.clone().multiplyScalar(enemy.speed));
                        if (enemy.position.distanceTo(enemy.initialPosition) > enemy.range) {
                            enemy.direction.negate();
                        }
                    }
                });

                // Update pet position
                if (currentPet) {
                    // Pet follows player with a slight delay/offset
                    const targetPosition = new THREE.Vector3(player.position.x + 1, player.position.y, player.position.z + 1);
                    currentPet.position.lerp(targetPosition, 0.1); // Smooth follow
                }

                // Update dynamic obstacles
                dynamicObstacles.forEach(obstacle => {
                    if (obstacle.isDynamicObstacle) {
                        if (obstacle.isMovingPlatform) {
                            if (obstacle.axis === 'x') {
                                obstacle.position.x += obstacle.speed * obstacle.direction;
                                if (Math.abs(obstacle.position.x - obstacle.initialPosition.x) > obstacle.travelDistance / 2) {
                                    obstacle.direction *= -1;
                                }
                            } else if (obstacle.axis === 'z') {
                                obstacle.position.z += obstacle.speed * obstacle.direction;
                                if (Math.abs(obstacle.position.z - obstacle.initialPosition.z) > obstacle.travelDistance / 2) {
                                    obstacle.direction *= -1;
                                }
                            }
                        } else if (obstacle.isLaserGrid) {
                            if (Date.now() - obstacle.lastToggleTime > obstacle.interval) {
                                obstacle.isActive = !obstacle.isActive;
                                obstacle.children.forEach(beam => {
                                    beam.visible = obstacle.isActive;
                                });
                                obstacle.lastToggleTime = Date.now();
                                if (obstacle.isActive && laserSound) laserSound.triggerAttackRelease("D6", "8n");
                            }
                        }
                    }
                });

                // Rotate coins
                coinsInLevel.forEach(coin => {
                    coin.rotation.z += 0.05; // Spin around its local Z axis (which is vertical)
                });

                checkCollisions();
            }

            updateUI();
            renderer.render(scene, camera);
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the game when the window loads
        window.onload = async function() { // Made window.onload function async
            await initGame();
        };
    </script>
</body>
</html>
